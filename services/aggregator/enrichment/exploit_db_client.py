"""
Exploit-DB Client

Checks for publicly available exploits for CVEs.
"""

import httpx
from typing import Dict, Any, Optional, List
from datetime import datetime, timedelta
import logging

logger = logging.getLogger(__name__)


class ExploitDBClient:
    """
    Client for checking exploit availability.

    Uses multiple sources:
    - Exploit-DB via searchsploit
    - GitHub exploit repositories
    - CISA KEV (Known Exploited Vulnerabilities)
    """

    def __init__(self):
        """Initialize Exploit-DB client"""
        self.kev_url = "https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json"
        self.cache: Dict[str, Dict[str, Any]] = {}
        self.cache_expiry: Dict[str, datetime] = {}
        self.cache_ttl = timedelta(days=7)  # Cache for 7 days

        # Known Exploited Vulnerabilities cache
        self.kev_data: Optional[Dict[str, Any]] = None
        self.kev_last_update: Optional[datetime] = None

        self.client = httpx.AsyncClient(
            timeout=30.0,
            headers={"Accept": "application/json"},
        )

        self.logger = logging.getLogger(__name__)

    async def check_exploit_availability(self, cve_id: str) -> Dict[str, Any]:
        """
        Check if exploits are available for a CVE.

        Args:
            cve_id: CVE identifier

        Returns:
            Dict with exploit information
        """
        # Check cache
        if cve_id in self.cache:
            if datetime.utcnow() < self.cache_expiry.get(cve_id, datetime.min):
                self.logger.debug(f"Exploit cache hit for {cve_id}")
                return self.cache[cve_id]

        result = {
            "cve_id": cve_id,
            "exploit_available": False,
            "exploit_maturity": "none",  # none, proof_of_concept, functional, high
            "in_cisa_kev": False,
            "sources": [],
        }

        try:
            # Check CISA KEV catalog
            in_kev = await self._check_cisa_kev(cve_id)
            if in_kev:
                result["exploit_available"] = True
                result["exploit_maturity"] = "high"  # KEV means actively exploited
                result["in_cisa_kev"] = True
                result["sources"].append("cisa_kev")

            # TODO: Add more sources (Exploit-DB API, GitHub search, etc.)
            # For MVP, we'll rely on CISA KEV

            # Cache the result
            self.cache[cve_id] = result
            self.cache_expiry[cve_id] = datetime.utcnow() + self.cache_ttl

            return result

        except Exception as e:
            self.logger.error(f"Error checking exploit availability for {cve_id}: {e}")
            return result

    async def _check_cisa_kev(self, cve_id: str) -> bool:
        """
        Check if CVE is in CISA Known Exploited Vulnerabilities catalog.

        Args:
            cve_id: CVE identifier

        Returns:
            bool: True if CVE is in KEV catalog
        """
        try:
            # Update KEV data if needed (daily)
            if not self.kev_data or not self.kev_last_update:
                await self._update_kev_data()
            elif datetime.utcnow() - self.kev_last_update > timedelta(days=1):
                await self._update_kev_data()

            # Search for CVE in KEV data
            if self.kev_data:
                vulnerabilities = self.kev_data.get("vulnerabilities", [])
                for vuln in vulnerabilities:
                    if vuln.get("cveID") == cve_id:
                        return True

            return False

        except Exception as e:
            self.logger.error(f"Error checking CISA KEV for {cve_id}: {e}")
            return False

    async def _update_kev_data(self):
        """Fetch latest CISA KEV data"""
        try:
            response = await self.client.get(self.kev_url)

            if response.status_code == 200:
                self.kev_data = response.json()
                self.kev_last_update = datetime.utcnow()
                vuln_count = len(self.kev_data.get("vulnerabilities", []))
                self.logger.info(f"Updated CISA KEV catalog: {vuln_count} vulnerabilities")
            else:
                self.logger.error(f"Failed to fetch CISA KEV: {response.status_code}")

        except Exception as e:
            self.logger.error(f"Error updating CISA KEV data: {e}")

    async def get_bulk_exploit_info(self, cve_ids: List[str]) -> Dict[str, Dict[str, Any]]:
        """
        Check exploit availability for multiple CVEs.

        Args:
            cve_ids: List of CVE identifiers

        Returns:
            Dict mapping CVE ID to exploit information
        """
        results = {}

        # Ensure KEV data is loaded
        if not self.kev_data:
            await self._update_kev_data()

        for cve_id in cve_ids:
            results[cve_id] = await self.check_exploit_availability(cve_id)

        return results

    async def __aenter__(self):
        """Async context manager entry"""
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager exit"""
        await self.client.aclose()
