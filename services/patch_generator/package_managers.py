"""
Package manager adapters for different Linux distributions
"""

from typing import Dict, Any, List, Optional
from abc import ABC, abstractmethod
from dataclasses import dataclass
import structlog

logger = structlog.get_logger()


@dataclass
class PackageInfo:
    """Package information"""

    name: str
    current_version: Optional[str]
    available_version: Optional[str]
    repository: Optional[str]
    architecture: Optional[str]


class PackageManager(ABC):
    """Abstract base class for package managers"""

    def __init__(self):
        self.manager_name = self.__class__.__name__.replace("Manager", "").lower()

    @abstractmethod
    def get_update_command(
        self,
        package_name: str,
        target_version: Optional[str] = None,
    ) -> str:
        """
        Get command to update a package

        Args:
            package_name: Name of the package
            target_version: Specific version to install (None for latest)

        Returns:
            Shell command string
        """
        pass

    @abstractmethod
    def get_install_command(
        self,
        package_name: str,
        version: Optional[str] = None,
    ) -> str:
        """
        Get command to install a package

        Args:
            package_name: Name of the package
            version: Specific version to install

        Returns:
            Shell command string
        """
        pass

    @abstractmethod
    def get_version_check_command(self, package_name: str) -> str:
        """
        Get command to check installed package version

        Args:
            package_name: Name of the package

        Returns:
            Shell command string
        """
        pass

    @abstractmethod
    def get_rollback_command(
        self,
        package_name: str,
        previous_version: str,
    ) -> str:
        """
        Get command to rollback to previous version

        Args:
            package_name: Name of the package
            previous_version: Version to rollback to

        Returns:
            Shell command string
        """
        pass

    def get_package_hold_command(self, package_name: str) -> Optional[str]:
        """
        Get command to hold/pin a package version

        Args:
            package_name: Name of the package

        Returns:
            Shell command string or None if not supported
        """
        return None

    def get_package_unhold_command(self, package_name: str) -> Optional[str]:
        """
        Get command to unhold/unpin a package version

        Args:
            package_name: Name of the package

        Returns:
            Shell command string or None if not supported
        """
        return None


class AptManager(PackageManager):
    """Debian/Ubuntu APT package manager"""

    def get_update_command(
        self,
        package_name: str,
        target_version: Optional[str] = None,
    ) -> str:
        if target_version:
            return f"apt-get install -y {package_name}={target_version}"
        return f"apt-get install -y --only-upgrade {package_name}"

    def get_install_command(
        self,
        package_name: str,
        version: Optional[str] = None,
    ) -> str:
        if version:
            return f"apt-get install -y {package_name}={version}"
        return f"apt-get install -y {package_name}"

    def get_version_check_command(self, package_name: str) -> str:
        return f"dpkg-query -W -f='${{Version}}' {package_name} 2>/dev/null || echo 'not-installed'"

    def get_rollback_command(
        self,
        package_name: str,
        previous_version: str,
    ) -> str:
        return f"apt-get install -y --allow-downgrades {package_name}={previous_version}"

    def get_package_hold_command(self, package_name: str) -> str:
        return f"apt-mark hold {package_name}"

    def get_package_unhold_command(self, package_name: str) -> str:
        return f"apt-mark unhold {package_name}"

    def build_patch_script(
        self,
        package_name: str,
        target_version: Optional[str] = None,
        pre_checks: bool = True,
    ) -> str:
        """Build a complete patch script for APT"""
        script_parts = [
            "#!/bin/bash",
            "set -euo pipefail",
            "",
            "# Remediation script generated by VulnZero",
            f"# Package: {package_name}",
            f"# Target Version: {target_version or 'latest'}",
            "",
        ]

        if pre_checks:
            script_parts.extend([
                "# Pre-flight checks",
                "if ! command -v apt-get &> /dev/null; then",
                "    echo 'ERROR: apt-get not found'",
                "    exit 1",
                "fi",
                "",
                "# Check if running as root",
                "if [ \"$EUID\" -ne 0 ]; then",
                "    echo 'ERROR: This script must be run as root'",
                "    exit 1",
                "fi",
                "",
                f"# Save current version for rollback",
                f"CURRENT_VERSION=$({self.get_version_check_command(package_name)})",
                "echo \"Current version: $CURRENT_VERSION\"",
                "",
            ])

        script_parts.extend([
            "# Update package lists",
            "echo 'Updating package lists...'",
            "apt-get update -qq",
            "",
            "# Perform upgrade",
            f"echo 'Upgrading {package_name}...'",
            self.get_update_command(package_name, target_version),
            "",
            "# Verify installation",
            f"NEW_VERSION=$({self.get_version_check_command(package_name)})",
            "echo \"New version: $NEW_VERSION\"",
            "",
        ])

        if target_version:
            script_parts.extend([
                "# Verify target version installed",
                f"if [ \"$NEW_VERSION\" != \"{target_version}\" ]; then",
                f"    echo 'WARNING: Installed version does not match target ({target_version})'",
                "fi",
                "",
            ])

        script_parts.append("echo 'Patch completed successfully'")

        return "\n".join(script_parts)

    def build_rollback_script(
        self,
        package_name: str,
        previous_version: str,
    ) -> str:
        """Build rollback script for APT"""
        return "\n".join([
            "#!/bin/bash",
            "set -euo pipefail",
            "",
            f"# Rollback script for {package_name}",
            f"# Reverting to version: {previous_version}",
            "",
            "if [ \"$EUID\" -ne 0 ]; then",
            "    echo 'ERROR: This script must be run as root'",
            "    exit 1",
            "fi",
            "",
            f"echo 'Rolling back {package_name} to {previous_version}...'",
            self.get_rollback_command(package_name, previous_version),
            "",
            f"NEW_VERSION=$({self.get_version_check_command(package_name)})",
            "echo \"Rollback complete. Current version: $NEW_VERSION\"",
        ])


class YumManager(PackageManager):
    """RHEL/CentOS/Fedora YUM/DNF package manager"""

    def __init__(self, use_dnf: bool = True):
        super().__init__()
        self.command = "dnf" if use_dnf else "yum"

    def get_update_command(
        self,
        package_name: str,
        target_version: Optional[str] = None,
    ) -> str:
        if target_version:
            return f"{self.command} install -y {package_name}-{target_version}"
        return f"{self.command} update -y {package_name}"

    def get_install_command(
        self,
        package_name: str,
        version: Optional[str] = None,
    ) -> str:
        if version:
            return f"{self.command} install -y {package_name}-{version}"
        return f"{self.command} install -y {package_name}"

    def get_version_check_command(self, package_name: str) -> str:
        return f"rpm -q --queryformat '%{{VERSION}}-%{{RELEASE}}' {package_name} 2>/dev/null || echo 'not-installed'"

    def get_rollback_command(
        self,
        package_name: str,
        previous_version: str,
    ) -> str:
        return f"{self.command} downgrade -y {package_name}-{previous_version}"

    def get_package_hold_command(self, package_name: str) -> str:
        return f"{self.command} versionlock add {package_name}"

    def get_package_unhold_command(self, package_name: str) -> str:
        return f"{self.command} versionlock delete {package_name}"

    def build_patch_script(
        self,
        package_name: str,
        target_version: Optional[str] = None,
        pre_checks: bool = True,
    ) -> str:
        """Build a complete patch script for YUM/DNF"""
        script_parts = [
            "#!/bin/bash",
            "set -euo pipefail",
            "",
            "# Remediation script generated by VulnZero",
            f"# Package: {package_name}",
            f"# Target Version: {target_version or 'latest'}",
            "",
        ]

        if pre_checks:
            script_parts.extend([
                "# Pre-flight checks",
                f"if ! command -v {self.command} &> /dev/null; then",
                f"    echo 'ERROR: {self.command} not found'",
                "    exit 1",
                "fi",
                "",
                "# Check if running as root",
                "if [ \"$EUID\" -ne 0 ]; then",
                "    echo 'ERROR: This script must be run as root'",
                "    exit 1",
                "fi",
                "",
                f"# Save current version for rollback",
                f"CURRENT_VERSION=$({self.get_version_check_command(package_name)})",
                "echo \"Current version: $CURRENT_VERSION\"",
                "",
            ])

        script_parts.extend([
            "# Perform upgrade",
            f"echo 'Upgrading {package_name}...'",
            self.get_update_command(package_name, target_version),
            "",
            "# Verify installation",
            f"NEW_VERSION=$({self.get_version_check_command(package_name)})",
            "echo \"New version: $NEW_VERSION\"",
            "",
            "echo 'Patch completed successfully'",
        ])

        return "\n".join(script_parts)

    def build_rollback_script(
        self,
        package_name: str,
        previous_version: str,
    ) -> str:
        """Build rollback script for YUM/DNF"""
        return "\n".join([
            "#!/bin/bash",
            "set -euo pipefail",
            "",
            f"# Rollback script for {package_name}",
            f"# Reverting to version: {previous_version}",
            "",
            "if [ \"$EUID\" -ne 0 ]; then",
            "    echo 'ERROR: This script must be run as root'",
            "    exit 1",
            "fi",
            "",
            f"echo 'Rolling back {package_name} to {previous_version}...'",
            self.get_rollback_command(package_name, previous_version),
            "",
            f"NEW_VERSION=$({self.get_version_check_command(package_name)})",
            "echo \"Rollback complete. Current version: $NEW_VERSION\"",
        ])


class ZypperManager(PackageManager):
    """openSUSE/SLES Zypper package manager"""

    def get_update_command(
        self,
        package_name: str,
        target_version: Optional[str] = None,
    ) -> str:
        if target_version:
            return f"zypper install -y {package_name}={target_version}"
        return f"zypper update -y {package_name}"

    def get_install_command(
        self,
        package_name: str,
        version: Optional[str] = None,
    ) -> str:
        if version:
            return f"zypper install -y {package_name}={version}"
        return f"zypper install -y {package_name}"

    def get_version_check_command(self, package_name: str) -> str:
        return f"rpm -q --queryformat '%{{VERSION}}-%{{RELEASE}}' {package_name} 2>/dev/null || echo 'not-installed'"

    def get_rollback_command(
        self,
        package_name: str,
        previous_version: str,
    ) -> str:
        return f"zypper install -y --oldpackage {package_name}={previous_version}"

    def get_package_hold_command(self, package_name: str) -> str:
        return f"zypper addlock {package_name}"

    def get_package_unhold_command(self, package_name: str) -> str:
        return f"zypper removelock {package_name}"

    def build_patch_script(
        self,
        package_name: str,
        target_version: Optional[str] = None,
        pre_checks: bool = True,
    ) -> str:
        """Build a complete patch script for Zypper"""
        script_parts = [
            "#!/bin/bash",
            "set -euo pipefail",
            "",
            "# Remediation script generated by VulnZero",
            f"# Package: {package_name}",
            f"# Target Version: {target_version or 'latest'}",
            "",
        ]

        if pre_checks:
            script_parts.extend([
                "# Pre-flight checks",
                "if ! command -v zypper &> /dev/null; then",
                "    echo 'ERROR: zypper not found'",
                "    exit 1",
                "fi",
                "",
                "# Check if running as root",
                "if [ \"$EUID\" -ne 0 ]; then",
                "    echo 'ERROR: This script must be run as root'",
                "    exit 1",
                "fi",
                "",
                f"# Save current version for rollback",
                f"CURRENT_VERSION=$({self.get_version_check_command(package_name)})",
                "echo \"Current version: $CURRENT_VERSION\"",
                "",
            ])

        script_parts.extend([
            "# Refresh repositories",
            "echo 'Refreshing repositories...'",
            "zypper refresh",
            "",
            "# Perform upgrade",
            f"echo 'Upgrading {package_name}...'",
            self.get_update_command(package_name, target_version),
            "",
            "# Verify installation",
            f"NEW_VERSION=$({self.get_version_check_command(package_name)})",
            "echo \"New version: $NEW_VERSION\"",
            "",
            "echo 'Patch completed successfully'",
        ])

        return "\n".join(script_parts)

    def build_rollback_script(
        self,
        package_name: str,
        previous_version: str,
    ) -> str:
        """Build rollback script for Zypper"""
        return "\n".join([
            "#!/bin/bash",
            "set -euo pipefail",
            "",
            f"# Rollback script for {package_name}",
            f"# Reverting to version: {previous_version}",
            "",
            "if [ \"$EUID\" -ne 0 ]; then",
            "    echo 'ERROR: This script must be run as root'",
            "    exit 1",
            "fi",
            "",
            f"echo 'Rolling back {package_name} to {previous_version}...'",
            self.get_rollback_command(package_name, previous_version),
            "",
            f"NEW_VERSION=$({self.get_version_check_command(package_name)})",
            "echo \"Rollback complete. Current version: $NEW_VERSION\"",
        ])


def get_package_manager(os_type: str, os_version: Optional[str] = None) -> PackageManager:
    """
    Get appropriate package manager based on OS type

    Args:
        os_type: Operating system type (debian, ubuntu, rhel, centos, fedora, opensuse, sles)
        os_version: OS version (optional, used for specific variations)

    Returns:
        PackageManager instance
    """
    os_type = os_type.lower()

    if os_type in ["debian", "ubuntu"]:
        return AptManager()
    elif os_type in ["rhel", "centos", "rocky", "alma"]:
        # RHEL 8+ uses DNF
        use_dnf = True
        if os_version and os_version.startswith("7"):
            use_dnf = False
        return YumManager(use_dnf=use_dnf)
    elif os_type == "fedora":
        return YumManager(use_dnf=True)
    elif os_type in ["opensuse", "sles"]:
        return ZypperManager()
    else:
        logger.warning("unknown_os_type", os_type=os_type)
        # Default to APT
        return AptManager()
