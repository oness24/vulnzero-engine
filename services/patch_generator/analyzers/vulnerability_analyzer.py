"""
Vulnerability Analyzer

Analyzes CVE data and determines patch strategy and requirements.
"""

from typing import Dict, Any, Optional, List
from enum import Enum
from pydantic import BaseModel
import re
import logging

from shared.models import Vulnerability

logger = logging.getLogger(__name__)


class PatchType(str, Enum):
    """Type of patch to generate"""
    PACKAGE_UPDATE = "package_update"
    CONFIG_CHANGE = "config_change"
    WORKAROUND = "workaround"
    KERNEL_PATCH = "kernel_patch"
    MANUAL = "manual"  # Requires manual intervention


class PackageManager(str, Enum):
    """Supported package managers"""
    APT = "apt"  # Debian/Ubuntu
    YUM = "yum"  # RHEL/CentOS
    DNF = "dnf"  # Fedora/RHEL 8+
    ZYPPER = "zypper"  # SUSE
    UNKNOWN = "unknown"


class AnalysisResult(BaseModel):
    """Result of vulnerability analysis"""
    vulnerability_id: int
    cve_id: str
    patch_type: PatchType
    package_manager: PackageManager
    affected_package: Optional[str] = None
    affected_version: Optional[str] = None
    fixed_version: Optional[str] = None
    os_type: Optional[str] = None
    confidence: float = 0.0  # 0.0-1.0
    complexity: str = "medium"  # low, medium, high
    requires_reboot: bool = False
    breaking_changes: bool = False
    dependencies: List[str] = []
    recommendations: List[str] = []
    context: Dict[str, Any] = {}


class VulnerabilityAnalyzer:
    """
    Analyzes vulnerabilities to determine patch strategy.
    """

    def __init__(self):
        """Initialize vulnerability analyzer"""
        self.logger = logging.getLogger(__name__)

    async def analyze(
        self,
        vulnerability: Vulnerability,
        asset_context: Optional[Dict[str, Any]] = None
    ) -> AnalysisResult:
        """
        Analyze vulnerability and determine patch strategy.

        Args:
            vulnerability: Vulnerability model
            asset_context: Optional context about the affected asset

        Returns:
            AnalysisResult with patch strategy
        """
        asset_context = asset_context or {}

        # Detect package manager from asset
        package_manager = self._detect_package_manager(
            vulnerability, asset_context
        )

        # Detect patch type
        patch_type = self._detect_patch_type(vulnerability)

        # Calculate confidence based on available information
        confidence = self._calculate_confidence(vulnerability)

        # Determine complexity
        complexity = self._determine_complexity(vulnerability, patch_type)

        # Check if reboot required
        requires_reboot = self._check_reboot_required(vulnerability)

        # Extract package information
        package_info = self._extract_package_info(vulnerability)

        # Generate recommendations
        recommendations = self._generate_recommendations(
            vulnerability, patch_type, package_manager
        )

        result = AnalysisResult(
            vulnerability_id=vulnerability.id,
            cve_id=vulnerability.cve_id,
            patch_type=patch_type,
            package_manager=package_manager,
            affected_package=package_info.get("package"),
            affected_version=package_info.get("version"),
            fixed_version=package_info.get("fixed_version"),
            os_type=asset_context.get("os_type"),
            confidence=confidence,
            complexity=complexity,
            requires_reboot=requires_reboot,
            breaking_changes=self._check_breaking_changes(vulnerability),
            dependencies=package_info.get("dependencies", []),
            recommendations=recommendations,
            context={
                "severity": vulnerability.severity.value if vulnerability.severity else "unknown",
                "cvss_score": vulnerability.cvss_score,
                "epss_score": vulnerability.epss_score,
                "exploit_available": vulnerability.exploit_available,
            },
        )

        self.logger.info(
            f"Analyzed {vulnerability.cve_id}: type={patch_type.value}, "
            f"confidence={confidence:.2f}, complexity={complexity}"
        )

        return result

    def _detect_package_manager(
        self,
        vulnerability: Vulnerability,
        asset_context: Dict[str, Any]
    ) -> PackageManager:
        """Detect appropriate package manager based on asset OS"""
        os_type = asset_context.get("os_type", "").lower()

        if "ubuntu" in os_type or "debian" in os_type:
            return PackageManager.APT
        elif "rhel" in os_type or "centos" in os_type or "red hat" in os_type:
            # Check version for dnf vs yum
            os_version = asset_context.get("os_version", "")
            if "8" in os_version or "9" in os_version:
                return PackageManager.DNF
            return PackageManager.YUM
        elif "fedora" in os_type:
            return PackageManager.DNF
        elif "suse" in os_type or "sles" in os_type:
            return PackageManager.ZYPPER
        else:
            # Try to infer from package name
            if vulnerability.affected_package:
                pkg = vulnerability.affected_package.lower()
                if ".deb" in pkg:
                    return PackageManager.APT
                elif ".rpm" in pkg:
                    return PackageManager.YUM

            return PackageManager.UNKNOWN

    def _detect_patch_type(self, vulnerability: Vulnerability) -> PatchType:
        """Determine what type of patch is needed"""
        title = (vulnerability.title or "").lower()
        description = (vulnerability.description or "").lower()
        cve_id = vulnerability.cve_id.lower()

        # Check for kernel vulnerabilities
        if any(keyword in title + description for keyword in ["kernel", "linux kernel"]):
            return PatchType.KERNEL_PATCH

        # Check if package update available
        if vulnerability.affected_package or "package" in title:
            return PatchType.PACKAGE_UPDATE

        # Check for configuration-related issues
        if any(keyword in title + description for keyword in [
            "configuration", "misconfiguration", "settings", "permissions"
        ]):
            return PatchType.CONFIG_CHANGE

        # Check if workaround is mentioned
        if "workaround" in title + description:
            return PatchType.WORKAROUND

        # Default to package update if we have package info
        if vulnerability.affected_package:
            return PatchType.PACKAGE_UPDATE

        # Otherwise, might require manual intervention
        return PatchType.MANUAL

    def _calculate_confidence(self, vulnerability: Vulnerability) -> float:
        """Calculate confidence score based on available data"""
        confidence = 0.0

        # Has CVE ID
        if vulnerability.cve_id and vulnerability.cve_id.startswith("CVE-"):
            confidence += 0.2

        # Has package information
        if vulnerability.affected_package:
            confidence += 0.3

        # Has fixed version
        if hasattr(vulnerability, 'fixed_version') and vulnerability.fixed_version:
            confidence += 0.3

        # Has CVSS score
        if vulnerability.cvss_score:
            confidence += 0.1

        # Has description
        if vulnerability.description and len(vulnerability.description) > 50:
            confidence += 0.1

        return min(1.0, confidence)

    def _determine_complexity(
        self,
        vulnerability: Vulnerability,
        patch_type: PatchType
    ) -> str:
        """Determine patch complexity"""
        # Kernel patches are always high complexity
        if patch_type == PatchType.KERNEL_PATCH:
            return "high"

        # Manual interventions are high complexity
        if patch_type == PatchType.MANUAL:
            return "high"

        # Config changes are usually medium
        if patch_type == PatchType.CONFIG_CHANGE:
            return "medium"

        # Package updates are low complexity
        if patch_type == PatchType.PACKAGE_UPDATE:
            return "low"

        return "medium"

    def _check_reboot_required(self, vulnerability: Vulnerability) -> bool:
        """Check if patch requires system reboot"""
        keywords = ["kernel", "systemd", "init", "boot"]
        text = f"{vulnerability.title} {vulnerability.description}".lower()

        return any(keyword in text for keyword in keywords)

    def _check_breaking_changes(self, vulnerability: Vulnerability) -> bool:
        """Check if patch might introduce breaking changes"""
        keywords = ["breaking", "incompatible", "deprecated", "removed"]
        text = f"{vulnerability.title} {vulnerability.description}".lower()

        return any(keyword in text for keyword in keywords)

    def _extract_package_info(self, vulnerability: Vulnerability) -> Dict[str, Any]:
        """Extract package-related information"""
        return {
            "package": vulnerability.affected_package,
            "version": getattr(vulnerability, 'affected_version', None),
            "fixed_version": getattr(vulnerability, 'fixed_version', None),
            "dependencies": [],  # TODO: Extract from NVD data if available
        }

    def _generate_recommendations(
        self,
        vulnerability: Vulnerability,
        patch_type: PatchType,
        package_manager: PackageManager
    ) -> List[str]:
        """Generate recommendations for patching"""
        recommendations = []

        # Severity-based recommendations
        if vulnerability.severity and vulnerability.severity.value == "critical":
            recommendations.append("Deploy patch immediately due to critical severity")

        # Exploit-based recommendations
        if vulnerability.exploit_available:
            recommendations.append("Public exploit available - prioritize patching")

        # EPSS-based recommendations
        if vulnerability.epss_score and vulnerability.epss_score > 0.5:
            recommendations.append(f"High exploitation probability ({vulnerability.epss_score:.1%}) - urgent patching recommended")

        # Type-specific recommendations
        if patch_type == PatchType.KERNEL_PATCH:
            recommendations.append("Kernel patch requires system reboot")
            recommendations.append("Test in staging environment first")

        elif patch_type == PatchType.CONFIG_CHANGE:
            recommendations.append("Configuration change - backup current configuration before applying")

        elif patch_type == PatchType.PACKAGE_UPDATE:
            if package_manager == PackageManager.UNKNOWN:
                recommendations.append("Unable to determine package manager - manual intervention may be required")

        return recommendations
